
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fight Club - 2</title>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
    <style>

        #chart {
            width: 100%;
            height: 500px;
            margin-top: 100px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 50px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        th {
            background-color: #f4f4f4;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="chart"></div>

    <table id="data-table">
        <thead>
            <tr>
                <th data-column="class">Class</th>
                <th data-column="wins">Wins</th>
                <th data-column="losses">Losses</th>
                <th data-column="winrate">Win Rate (%)</th>
                <th data-column="damage">Damage Done</th>
                <th data-column="healing">Healing Done</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>
    <script>
        var chart = echarts.init(document.getElementById('chart'));

        // Sample data
        var classes = ['Thane', 'Reaver', 'Healer', 'Heretic', 'Friar', 'Cleric', 'Nightshade', 'Bainshee', 'Enchanter', 'Bonedancer', 'Armsman', 'Shaman', 'Eldritch', 'Valkyrie', 'Champion', 'Hunter', 'Shadowblade', 'Ranger', 'Runemaster', 'Minstrel', 'Valewalker', 'Occultist', 'Scout', 'Spiritmaster', 'Warrior', 'Vampiir', 'Druid', 'Berserker', 'Hero', 'Infiltrator', 'Warlock', 'Cabalist', 'Warden', 'Blademaster', 'Mentalist', 'Mercenary', 'Paladin', 'Skald', 'Bard', 'Theurgist', 'Sorcerer', 'Wizard', 'Animist', 'Savage', 'Necromancer'];
        var rawData = [];
        var rawDataTimes = rawData.map(d => new Date(d.time).getTime());  // Convert to timestamp (milliseconds)
        var originalMinTime = new Date(Math.min(...rawDataTimes));  // Get the minimum timestamp
        var originalMaxTime = new Date(Math.max(...rawDataTimes));  // Get the maximum timestamp
        // Initial start and end time for filtering (based on raw data)

        // Track the current time window
        let currentMinTime = originalMinTime;
        let currentMaxTime = originalMaxTime;

        function processData(startTime, endTime) {
            // Filter the raw data based on the selected time range
            let filteredData = rawData.filter(d => new Date(d.time) >= startTime && new Date(d.time) <= endTime);
            let groupedData = {};

            // Group the filtered data by class
            filteredData.forEach(d => {
                if (!groupedData[d.class]) groupedData[d.class] = { wins: 0, losses: 0, damage: 0, healing: 0 };
                groupedData[d.class].wins += d.wins;
                groupedData[d.class].losses += d.losses;
                groupedData[d.class].damage += d['damage done'];
                groupedData[d.class].healing += d['healing done'];
            });

            let seriesData = classes.map(className => ({
                name: className,
                type: 'line',
                smooth: true,
                data: filteredData.filter(d => d.class === className).map(d => [new Date(d.time).getTime(), d.wins])
            }));

            // Create table data based on the filtered (grouped) data
            let tableData = Object.keys(groupedData).map(className => {
                let { wins, losses, damage, healing } = groupedData[className];
                let winRate = wins + losses === 0 ? 0 : ((wins / (wins + losses)) * 100).toFixed(2);
                return {
                    class: className,
                    wins: wins,
                    losses: losses,
                    winRate: winRate,
                    damage: damage,
                    healing: healing
                };
            });

            updateTable(tableData);
            return seriesData;
        }

        function updateTable(tableData) {
            let tbody = document.querySelector("#data-table tbody");
            tbody.innerHTML = tableData.length ? tableData.map(row => {
                return `<tr>
                    <td data-column="class">${row.class}</td>
                    <td data-column="wins">${row.wins}</td>
                    <td data-column="losses">${row.losses}</td>
                    <td data-column="winrate">${row.winRate}%</td>
                    <td data-column="damage">${row.damage}</td>
                    <td data-column="healing">${row.healing}</td>
                </tr>`;
            }).join('') : "<tr><td colspan='6'>No data available in this range</td></tr>";
        }

        // Initial data processing
        let seriesData = processData(currentMinTime, currentMaxTime);

        var option = {
            title: {
                text: 'Wins by Class',
                left: "center"
            },
            tooltip: {
                trigger: 'axis'
            },
            legend: {
                data: classes,
                orient: 'horizontal',
                bottom: 50, // Add a little more padding here to move the legend down
                left: 'center'
            },
            grid: {
                bottom: 150 // Add space at the bottom for the legend and zoom slider
            },
            xAxis: {
                type: 'time',
                name: 'Time'
            },
            yAxis: {
                type: 'value',
                name: 'Wins'
            },
            dataZoom: [
                {
                    type: 'slider',
                    show: true,
                    xAxisIndex: 0,
                    start: 0,
                    end: 100
                },
                {
                    type: 'inside',
                    xAxisIndex: 0
                }
            ],
            series: seriesData
        };

        chart.setOption(option);
        chart.on('datazoom', function (params) {
            // Get the percentage values from the dataZoom event
            let startPercent = params.start; // 0 to 100
            let endPercent = params.end; // 0 to 100
    
            // Calculate the time range from the percentages (relative to the original data bounds)
            let timeRange = originalMaxTime.getTime() - originalMinTime.getTime();
            let newMinTime = new Date(originalMinTime.getTime() + (timeRange * startPercent / 100));
            let newMaxTime = new Date(originalMinTime.getTime() + (timeRange * endPercent / 100));
    
            // Only update if the time range has changed
            if (newMinTime.getTime() !== currentMinTime.getTime() || newMaxTime.getTime() !== currentMaxTime.getTime()) {
                currentMinTime = newMinTime;
                currentMaxTime = newMaxTime;
    
                // Reprocess data based on updated time range and refresh both the chart and table
                let newSeries = processData(currentMinTime, currentMaxTime);
                chart.setOption({ series: newSeries });
            }
        });

        // Sorting functionality for table
        // Ensure each table header has the corresponding data-column attribute
const tableHeaders = document.querySelectorAll('th');
tableHeaders.forEach(header => {
    header.addEventListener('click', function () {
        const column = this.getAttribute('data-column'); // Get the column name
        const rows = Array.from(document.querySelector('#data-table tbody').rows);

        // Determine sort order
        const currentSortOrder = this.dataset.sortOrder || 'asc';
        const newSortOrder = currentSortOrder === 'asc' ? 'desc' : 'asc';

        // Sort the rows based on the clicked column
        rows.sort((rowA, rowB) => {
            const valA = rowA.querySelector(`td[data-column="${column}"]`).innerText;
            const valB = rowB.querySelector(`td[data-column="${column}"]`).innerText;

            if (column === 'class') {
                return (valA > valB ? 1 : -1) * (newSortOrder === 'asc' ? 1 : -1);
            }            
            return (parseFloat(valA) - parseFloat(valB)) * (newSortOrder === 'asc' ? 1 : -1);
        });

        // Reorder the rows in the table body
        rows.forEach(row => {
            document.querySelector('#data-table tbody').appendChild(row);
        });

        // Update sort order in the header for the next click
        this.dataset.sortOrder = newSortOrder;
    });
});

    </script>
</body>
</html>
